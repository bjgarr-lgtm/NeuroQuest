<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SootheBirb â€” v2.6 single-file hotfix</title>
  <link rel="icon" href="assets/icon.svg" type="image/svg+xml"/>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css"/>
</head>
<body class="crt">
  <header class="app-header">
    <div class="brand" id="brand">
      <img src="assets/icon.svg" class="logo" alt=""/>
      <h1>SootheBirb</h1>
    </div>
    <div class="hud" id="hud">
      <div id="partyMini" class="party-mini"></div>
      <div class="gold" id="hudGold">ðŸª™ 0</div>
      <div class="xp">
        <span id="hudLevel">Lv 1</span><span class="flame">ðŸ”¥</span>
        <div class="bar"><div id="hudXp"></div></div>
      </div>
      <button id="hamb" class="hamb" aria-label="Menu">â˜°</button>
    </div>
  </header>

  <aside id="drawer" class="drawer"><nav id="nav"></nav></aside>
  <div id="scrim" class="scrim"></div>
  <main id="view" class="view"></main>

  <footer class="app-footer">
    <span id="streakLabel">Streak: 0 ðŸ”¥ | Best: 0</span>
    <span class="dot">â€¢</span>
    <button id="exportBtn" class="secondary">Export</button>
    <input type="file" id="importFile" accept="application/json" style="display:none"/>
    <button id="importBtn" class="secondary">Import</button>
  </footer>

  <div id="fxLayer" class="fx-layer" aria-hidden="true"></div>

  <!-- 0) STORAGE SHIM â€” MUST LOAD BEFORE YOUR APP -->
  <script>
  (function(){
    // Wipe the giant legacy key once (dev mode safety)
    try { localStorage.removeItem('sb_v26_state'); } catch(e){}

    const origSet = localStorage.setItem.bind(localStorage);
    localStorage.setItem = function(key, val){
      // Intercept the old giant blob and prune huge fields before saving
      if (key === 'sb_v26_state') {
        try {
          const obj = JSON.parse(val);
          // Kill any accidental image blobs/base64 branches
          if (obj?.wardrobe?.images) delete obj.wardrobe.images;
          if (obj?.pet?.images) delete obj.pet.images;
          if (obj?.overlays?.images) delete obj.overlays.images;
          // Also clamp history arrays if they exist
          if (Array.isArray(obj?.journal)) obj.journal = obj.journal.slice(-50);
          if (Array.isArray(obj?.moods)) obj.moods = obj.moods.slice(-100);
          val = JSON.stringify(obj);
        } catch(e) {/* ignore and try to save anyway */}
      }
      try {
        return origSet(key, val);
      } catch (e) {
        console.warn('storage shim: quota on', key, e);
        // Last-chance tiny save path to avoid hard crashes
        try {
          const obj = JSON.parse(val);
          const tiny = {
            user: obj.user, xp: obj.xp, gold: obj.gold,
            streak: obj.streak, settings: obj.settings,
            party: obj.party, overlays: obj.overlays
          };
          return origSet(key, JSON.stringify(tiny));
        } catch(e2) { /* give up silently */ }
      }
    };
  })();
  </script>

  <!-- 1) YOUR APP ENTRY (unchanged) -->
  <script type="module" src="js/app.js"></script>

  <!-- 2) INLINE ACCESSORY SYSTEM (IndexedDB + overlay manager + align tool) -->
  <script>
  (function(){
    // --- Lightweight state for overlays only (kept tiny) ---
    const KEY='sb_v26_overlay_state';
    const OverlayStore = {
      get(){ try{ return JSON.parse(localStorage.getItem(KEY)) || {}; }catch{ return {}; } },
      set(v){ try{ localStorage.setItem(KEY, JSON.stringify(v)); }catch(e){ console.warn('overlay store fail', e); } }
    };

    // --- IndexedDB blob store for accessory images ---
    const DB='sb_idb_inline_v1', ST='assets';
    function openDB(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB,1);
      r.onupgradeneeded=()=>{ const db=r.result; if(!db.objectStoreNames.contains(ST)) db.createObjectStore(ST,{keyPath:'id'}); };
      r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function idbPut(file){ const db=await openDB(); return new Promise((res,rej)=>{ const id=Math.random().toString(36).slice(2);
      const tx=db.transaction(ST,'readwrite'); tx.objectStore(ST).put({id,blob:file}); tx.oncomplete=()=>res(id); tx.onerror=()=>rej(tx.error); }); }
    async function idbGetURL(id){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(ST,'readonly'); const q=tx.objectStore(ST).get(id);
      q.onsuccess=()=>{ const r=q.result; res(r?URL.createObjectURL(r.blob):null); }; q.onerror=()=>rej(q.error); }); }

    // --- Overlay manager (per leader char) ---
    class OverlayMgr{
      constructor(layer){ this.layer=layer; this.state=OverlayStore.get(); }
      _arr(id){ return this.state[id]||(this.state[id]=[]); }
      save(){ OverlayStore.set(this.state); }
      async load(id){ this.layer.innerHTML=''; for(const o of this._arr(id)) this._spawn(o); }
      async add(id, o){ this._arr(id).push(o); this._spawn(o); this.save(); }
      async clear(id){ this.state[id]=[]; this.layer.innerHTML=''; this.save(); }
      _spawn(o){
        const img=new Image(); img.decoding='async'; img.loading='eager'; img.alt='overlay';
        img.src=o.url; img.className='sb-acc-ov'; Object.assign(img.style,{
          position:'absolute', left:(o.x*100)+'%', top:(o.y*100)+'%',
          transform:`translate(-50%,-50%) scale(${o.s||1}) rotate(${o.r||0}deg)`,
          pointerEvents:'none'
        }); this.layer.appendChild(img);
      }
    }

    // Align tool (drag, wheel, Shift+wheel)
    function ensureAlignBtn(){
      if(document.getElementById('sbAlignBtn')) return;
      const b=document.createElement('button'); b.id='sbAlignBtn'; b.textContent='ðŸ§©';
      Object.assign(b.style,{position:'fixed',right:'14px',bottom:'14px',zIndex:9999,padding:'10px',borderRadius:'12px'});
      b.title='Align last accessory (drag / wheel / Shift+wheel)';
      b.onclick=()=>{
        const layer=document.querySelector('.sb-acc-layer'); if(!layer){ alert('Open Character page first.'); return; }
        const active=layer.querySelector('.sb-acc-ov:last-of-type'); if(!active){ alert('Add an accessory first.'); return; }
        alert('Align: drag = move, wheel = scale, Shift+wheel = rotate (8s)');
        const onMove=(ev)=>{ const r=layer.getBoundingClientRect(); const x=(ev.clientX-r.left)/r.width, y=(ev.clientY-r.top)/r.height;
          active.style.left=(x*100)+'%'; active.style.top=(y*100)+'%'; };
        const onWheel=(ev)=>{ ev.preventDefault(); const m=(active.style.transform||'').match(/scale\\(([^)]+)\\).*rotate\\(([^)]+)deg\\)/);
          let s=1,r=0; if(m){ s=parseFloat(m[1]); r=parseFloat(m[2]); } if(ev.shiftKey) r+=(ev.deltaY>0?-4:4); else s+=(ev.deltaY>0?-0.06:0.06);
          active.style.transform=`translate(-50%,-50%) scale(${Math.max(.2,Math.min(5,s))}) rotate(${r}deg)`; };
        window.addEventListener('mousemove',onMove); window.addEventListener('wheel',onWheel,{passive:false});
        setTimeout(()=>{ window.removeEventListener('mousemove',onMove); window.removeEventListener('wheel',onWheel); },8000);
      };
      document.body.appendChild(b);
    }

    // Route observer: patch Character page after your app renders it
    function currentLeaderId(){
      const sel=document.querySelector('#leader');
      if(sel && sel.value) return sel.value;
      // fallback: try to read from small overlay storeâ€™s last known, else bambi
      const st=OverlayStore.get(); return st.__lastLeader || 'bambi';
    }
    function rememberLeader(id){ const st=OverlayStore.get(); st.__lastLeader=id; OverlayStore.set(st); }

    async function patchCharacter(){
      const portrait=document.querySelector('#portrait'); if(!portrait) return;
      let layer=document.querySelector('.sb-acc-layer');
      if(!layer){
        portrait.parentElement.style.position='relative';
        layer=document.createElement('div'); layer.className='sb-acc-layer';
        Object.assign(layer.style,{position:'absolute',left:0,top:0,width:'100%',height:'100%',pointerEvents:'none'});
        portrait.parentElement.appendChild(layer);
      }
      const mgr=new OverlayMgr(layer);
      const leaderSel=document.querySelector('#leader');
      const leaderId=leaderSel?.value || currentLeaderId(); rememberLeader(leaderId);
      await mgr.load(leaderId);

      const addBtn=document.querySelector('#addAcc');
      const fileIn=document.querySelector('#accFile');
      const clrBtn=document.querySelector('#clearAcc');

      if(addBtn && fileIn && !addBtn._sb_wired){
        addBtn._sb_wired=true;
        addBtn.addEventListener('click', async ()=>{
          const f=fileIn.files && fileIn.files[0]; if(!f){ alert('Choose an image first'); return; }
          try{
            const id=await idbPut(f); const url=await idbGetURL(id);
            if(!url){ alert('Accessory load failed'); return; }
            await mgr.add(leaderSel?.value || currentLeaderId(), { id, url, x:0.5, y:0.5, s:1, r:0 });
            alert('Accessory added. Click ðŸ§© to align it.');
          }catch(err){ console.error('Accessory add failed', err); alert('Accessory add failed: '+err); }
        });
      }
      if(clrBtn && !clrBtn._sb_wired){
        clrBtn._sb_wired=true;
        clrBtn.addEventListener('click', async ()=>{ await mgr.clear(leaderSel?.value || currentLeaderId()); alert('Cleared overlays.'); });
      }
      ensureAlignBtn();
    }

    function onRoute(){ setTimeout(patchCharacter, 60); }
    window.addEventListener('hashchange', onRoute);
    document.addEventListener('DOMContentLoaded', onRoute);
    setTimeout(onRoute, 200);
  })();
  </script>
</body>
</html>
