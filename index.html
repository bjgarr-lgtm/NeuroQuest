<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>NeuroQuest â€” v2.6 single-file align hotfix</title>
  <link rel="icon" href="assets/neuroquest-shield.svg" type="image/svg+xml"/>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css"/>
  <style>
    /* tiny helper styles so the toolbar looks sane even without CSS changes */
    .sb-align-bar{position:absolute; left:8px; top:8px; display:flex; gap:6px;
      background:rgba(10,10,20,.7); border:1px solid #4af; border-radius:10px; padding:6px; z-index:999}
    .sb-align-bar button{padding:6px 10px; border-radius:8px; border:1px solid #79f; background:#122; color:#fff; cursor:pointer}
    .sb-align-hint{position:absolute; right:8px; top:8px; background:rgba(0,0,0,.55); color:#fff;
      padding:6px 10px; border-radius:10px; font-size:.8rem; z-index:999; border:1px solid #456}
    .sb-acc-layer{position:absolute; left:0; top:0; width:100%; height:100%}
    .sb-acc-ov{position:absolute; transform:translate(-50%,-50%) scale(1) rotate(0deg); cursor:grab; user-select:none}
    .sb-acc-ov:active{cursor:grabbing}

/* === Canva-like editor helpers === */
.sb-grid{position:absolute; inset:0; background-image:
  linear-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
  linear-gradient(90deg, rgba(255,255,255,.06) 1px, transparent 1px);
  background-size: 40px 40px, 40px 40px; pointer-events:none; display:none}
.sb-grid.show{display:block}

.sb-acc-ov.selected{outline:2px dashed #7cf; outline-offset:2px}
.sb-handle{position:absolute; width:14px; height:14px; border:2px solid #7cf; background:#0b2238; border-radius:3px; pointer-events:auto; cursor:nwse-resize}
.sb-handle.ne{right:-7px; top:-7px}
.sb-handle.nw{left:-7px; top:-7px}
.sb-handle.se{right:-7px; bottom:-7px}
.sb-handle.sw{left:-7px; bottom:-7px}

.sb-rotate{position:absolute; top:-28px; left:50%; transform:translateX(-50%); width:14px; height:14px; border:2px solid #7cf; background:#0b2238; border-radius:50%; cursor:grab}
.sb-rotate:active{cursor:grabbing}
/* === end helpers === */
  </style>
<style id="patch-hide-toolbar">.sb-align-bar,.sb-align-hint,.acc-toolbar{display:none!important}</style>
</head>
<body class="crt">
  <header class="app-header">
    <div class="brand" id="brand">
      <img src="assets/neuroquest-shield.svg" class="logo" alt="NeuroQuest logo"/>
      <h1><a href="#home" class="logo-link">NeuroQuest</a></h1>
    </div>
    <div class="hud" id="hud">
      <div id="partyMini" class="party-mini"></div>
      <div class="gold" id="hudGold">ðŸª™ 0</div>
      <div class="xp">
        <span id="hudLevel">Lv 1</span><span class="flame">ðŸ”¥</span>
        <div class="bar"><div id="hudXp"></div></div>
      </div>
      <button id="musicBtn" class="hamb" title="Play/Pause music">â™ª</button>
      <input type="file" id="musicFile" accept="audio/*" style="display:none"/>
      <button id="hamb" class="hamb" aria-label="Menu">â˜°</button>
    </div>
  </header>

  <aside id="drawer" class="drawer"><nav id="nav"></nav></aside>
  <div id="scrim" class="scrim"></div>
  <main id="view" class="view"></main>

  <footer class="app-footer">
    <span id="streakLabel">Streak: 0 ðŸ”¥ | Best: 0</span>
    <span class="dot">â€¢</span>
    <button id="exportBtn" class="secondary">Export</button>
    <input type="file" id="importFile" accept="application/json" style="display:none"/>
    <button id="importBtn" class="secondary">Import</button>
  </footer>

  <div id="fxLayer" class="fx-layer" aria-hidden="true"></div>

  <!-- 0) STORAGE SHIM (prevents quota crashes) -->
  <script>
  (function(){
    const origSet = localStorage.setItem.bind(localStorage);
    localStorage.setItem = function(key, val){
      if (key === 'sb_v26_state') {
        try {
          const obj = JSON.parse(val);
          if (obj?.wardrobe?.images) delete obj.wardrobe.images;
          if (obj?.pet?.images) delete obj.pet.images;
          if (obj?.overlays?.images) delete obj.overlays.images;
          if (Array.isArray(obj?.journal)) obj.journal = obj.journal.slice(-50);
          if (Array.isArray(obj?.moods)) obj.moods = obj.moods.slice(-100);
          val = JSON.stringify(obj);
        } catch(e) {}
      }
      try { return origSet(key, val); }
      catch(e){
        try{
          const obj = JSON.parse(val);
          const tiny = { user: obj.user, xp: obj.xp, gold: obj.gold,
                         streak: obj.streak, settings: obj.settings,
                         party: obj.party, overlays: obj.overlays };
          return origSet(key, JSON.stringify(tiny));
        }catch(e2){ /* swallow */ }
      }
    };
  })();
  </script>

  <!-- 1) YOUR APP (unchanged) -->
  <script type="module" src="js/app.js"></script>

  <!-- 2) Inline IDB + overlay + ALIGN TOOL thatâ€™s visible on Character -->
  <script>
  (function(){
    // Small, separate state for overlays so we never bloat your main state
    const OKEY='sb_v26_overlay_state';
    const OStore = {
      get(){ try{ return JSON.parse(localStorage.getItem(OKEY))||{} }catch{ return {} } },
      set(v){ try{ localStorage.setItem(OKEY, JSON.stringify(v)) }catch(e){ console.warn('overlay save fail', e) } }
    };

    // IndexedDB for accessory images (no localStorage quota issue)
    const DB='sb_idb_inline_v1', ST='assets';
    function openDB(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB,1);
      r.onupgradeneeded=()=>{ const db=r.result; if(!db.objectStoreNames.contains(ST)) db.createObjectStore(ST,{keyPath:'id'}) };
      r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error) }) }
    async function idbPut(file){ const db=await openDB(); return new Promise((res,rej)=>{ const id=Math.random().toString(36).slice(2);
      const tx=db.transaction(ST,'readwrite'); tx.objectStore(ST).put({id,blob:file}); tx.oncomplete=()=>res(id); tx.onerror=()=>rej(tx.error) }) }
    async function idbGetURL(id){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(ST,'readonly'); const q=tx.objectStore(ST).get(id);
      q.onsuccess=()=>res(q.result?URL.createObjectURL(q.result.blob):null); q.onerror=()=>rej(q.error) }) }

    class OverlayMgr{
      constructor(layer){ this.layer=layer; this.S=OStore.get() }
      _arr(id){ return this.S[id]||(this.S[id]=[]) }
      save(){ OStore.set(this.S) }
      async load(id){ this.layer.innerHTML=''; for(const o of this._arr(id)) this._spawn(o) }
      async add(id,o){ this._arr(id).push(o); this._spawn(o); this.save() }
      async clear(id){ this.S[id]=[]; this.layer.innerHTML=''; this.save() }
      _spawn(o){
        const img=new Image(); img.decoding='async'; img.loading='eager'; img.src=o.url; img.alt='overlay';
        img.className='sb-acc-ov';
        // normalize + defaults
        const _nx=(o.x>1? o.x/100 : (o.x??0.5));
        const _ny=(o.y>1? o.y/100 : (o.y??0.5));
        const _nw=(o.w? (o.w>1? o.w : o.w*100) : 40);
        img.dataset.x=Math.max(0.05, Math.min(0.95, _nx));
        img.dataset.y=Math.max(0.05, Math.min(0.95, _ny));
        img.dataset.s=o.s??1; img.dataset.r=o.r??0;
        img.style.width = _nw + '%';
        this._apply(img); this.layer.appendChild(img)
      }
      _apply(el){
        const x=parseFloat(el.dataset.x), y=parseFloat(el.dataset.y),
              s=parseFloat(el.dataset.s), r=parseFloat(el.dataset.r);
        el.style.left=(x*100)+'%'; el.style.top=(y*100)+'%';
        el.style.transform=`translate(-50%,-50%) scale(${s}) rotate(${r}deg)`
      }
      updateLastTransform(id){
        const arr=this._arr(id); if(!arr.length) return;
        const last=this.layer.querySelector('.sb-acc-ov:last-of-type'); if(!last) return;
        arr[arr.length-1] = {
          id: arr[arr.length-1].id,
          url: arr[arr.length-1].url,
          x: parseFloat(last.dataset.x),
          y: parseFloat(last.dataset.y),
          s: parseFloat(last.dataset.s),
          r: parseFloat(last.dataset.r),
          w: (function(){ const w = parseFloat(last.style.width); return isNaN(w)?40:w; })()
        };
        this.save();
      }
      removeLast(id){ const arr=this._arr(id); if(!arr.length) return; arr.pop(); this.save(); }
    }

    // Build a visible align toolbar inside the portrait wrapper
    function injectAlignUI(wrap, mgr, leaderId){
      // remove existing
      wrap.querySelector('.sb-align-bar')?.remove();
      wrap.querySelector('.sb-align-hint')?.remove();

      const bar=document.createElement('div'); bar.className='sb-align-bar';
      bar.innerHTML = `        <button data-act="align">Align</button>        <button data-act="snap-center">Center</button>        <button data-act="left">Left</button>        <button data-act="right">Right</button>        <button data-act="top">Top</button>        <button data-act="bottom">Bottom</button>        <button data-act="flip">Flip</button>        <button data-act="front">Front</button>        <button data-act="back">Back</button>        <button data-act="dup">Duplicate</button>        <button data-act="grid">Grid</button>        <button data-act="save">Save</button>        <button data-act="clear">Clear</button>        <button data-act="exit">Exit</button>`;
      const hint=document.createElement('div'); hint.className='sb-align-hint';
      hint.textContent='Drag to move Â· Wheel to scale Â· Q/E to rotate';
      wrap.appendChild(bar); wrap.appendChild(hint); const grid=document.createElement('div'); grid.className='sb-grid'; wrap.appendChild(grid);

      let active=null, dragging=false, lastPos=null;

      function pickLast(){
        active = wrap.querySelector('.sb-acc-ov:last-of-type');
        return !!active;
      }
      function enableAlign(){
        select();
        if(!pickLast()){ alert('Add an accessory first.'); return; }
        // allow interaction
        active.style.pointerEvents='auto';
        // move
        active.addEventListener('mousedown', onDown);
        // scale (hover anywhere on wrapper)
        wrap.addEventListener('wheel', onWheel, {passive:false});
        // rotate by keys
        window.addEventListener('keydown', onKey);
      }
      function disableAlign(){
        if(active){
          active.style.pointerEvents='none';
          active.removeEventListener('mousedown', onDown);
        }
        wrap.removeEventListener('wheel', onWheel);
        window.removeEventListener('keydown', onKey);
        active=null; dragging=false; lastPos=null;
      }
      function onDown(ev){
        select(ev.target);
        ev.preventDefault(); dragging=true;
        const r=layer.getBoundingClientRect(); lastPos={r,ox:ev.clientX,oy:ev.clientY};
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
      }
      function onMove(ev){
        if(!dragging||!active||!lastPos) return;
        const {r}=lastPos;
        let x=(ev.clientX - r.left)/r.width, y=(ev.clientY - r.top)/r.height;
        x=Math.max(0,Math.min(1,x)); y=Math.max(0,Math.min(1,y));
        active.dataset.x=x; active.dataset.y=y;
        const xS=(x*100)+'%'; const yS=(y*100)+'%';
        active.style.left=xS; active.style.top=yS;
      }
      function onUp(){
        dragging=false; window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        mgr.updateLastTransform(leaderId);
      }
      function onWheel(ev){
        if(!active) return;
        ev.preventDefault();
        const s=parseFloat(active.dataset.s)||1;
        const delta = (ev.deltaY>0 ? -0.06 : 0.06);
        const ns = Math.max(.2, Math.min(5, s+delta));
        active.dataset.s = ns.toFixed(3);
        applyTRS();
      }
      function onKey(ev){
        if(!active) return;
        const step = ev.shiftKey ? 0.2 : 1;
        if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(ev.key)) ev.preventDefault();
        let x=parseFloat(active.dataset.x)||0.5, y=parseFloat(active.dataset.y)||0.5;
        if(ev.key==='ArrowLeft') x-=step/100;
        if(ev.key==='ArrowRight') x+=step/100;
        if(ev.key==='ArrowUp') y-=step/100;
        if(ev.key==='ArrowDown') y+=step/100;
        x=Math.max(0,Math.min(1,x)); y=Math.max(0,Math.min(1,y));
        active.dataset.x=x; active.dataset.y=y; active.style.left=(x*100)+'%'; active.style.top=(y*100)+'%';
        if(ev.key==='Delete' || ev.key==='Backspace'){ active.remove(); mgr.removeLast(leaderId); active=null; }
        positionHandles();
        if(!active) return;
        if(ev.key==='q' || ev.key==='Q'){ rotate(-4) }
        else if(ev.key==='e' || ev.key==='E'){ rotate(4) }
      }
      function rotate(d){
        const r=parseFloat(active.dataset.r)||0;
        active.dataset.r=(r+d).toFixed(2);
        applyTRS();
      }
      
      // selection + handles
      function select(el){
        wrap.querySelectorAll('.sb-acc-ov').forEach(e=>e.classList.remove('selected'));
        active = el || wrap.querySelector('.sb-acc-ov:last-of-type');
        if(!active) return false;
        active.classList.add('selected');
        ensureHandles();
        return true;
      }
      function ensureHandles(){
        // remove old
        wrap.querySelectorAll('.sb-handle,.sb-rotate').forEach(n=>n.remove());
        if(!active) return;
        const mk=(cls)=>{ const h=document.createElement('div'); h.className='sb-handle '+cls; wrap.appendChild(h); return h; };
        const ne=mk('ne'), nw=mk('nw'), se=mk('se'), sw=mk('sw');
        const rot=document.createElement('div'); rot.className='sb-rotate'; wrap.appendChild(rot);
        positionHandles();
        [ne,nw,se,sw].forEach(h=>h.addEventListener('mousedown', onResize));
        rot.addEventListener('mousedown', onRotate);
      }
      function positionHandles(){
        if(!active) return;
        const r=active.getBoundingClientRect(); const w=layer.getBoundingClientRect();
        const toWrap = (x,y)=>({ left:(x-w.left)+'px', top:(y-w.top)+'px' });
        const hh=(sel, x, y)=>{ const el=wrap.querySelector(sel); if(el){ const p=toWrap(x,y); el.style.left=p.left; el.style.top=p.top; } };
        hh('.sb-handle.ne', r.right, r.top);
        hh('.sb-handle.nw', r.left, r.top);
        hh('.sb-handle.se', r.right, r.bottom);
        hh('.sb-handle.sw', r.left, r.bottom);
        hh('.sb-rotate', r.left + r.width/2, r.top-14);
      }
      new ResizeObserver(()=>positionHandles()).observe(wrap);

      function onResize(ev){
        ev.preventDefault();
        const r=layer.getBoundingClientRect();
        const start={x:ev.clientX, y:ev.clientY, w:active.offsetWidth, h:active.offsetHeight};
        function mm(e){
          const dx=e.clientX-start.x, dy=e.clientY-start.y;
          const bigger = (ev.target.classList.contains('ne')||ev.target.classList.contains('se')) ? dx : -dx;
          const newW = Math.max(10, start.w + bigger);
          // convert to percentage of wrap width
          const wPct = (newW / r.width) * 100;
          active.style.width = wPct + '%';
          active.dataset.s = (wPct/ (parseFloat(active.style.width)||wPct)).toFixed(3); // maintain dataset s approx
          positionHandles();
        }
        function up(){ window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', up); mgr.updateLastTransform(leaderId); }
        window.addEventListener('mousemove', mm); window.addEventListener('mouseup', up);
      }
      function onRotate(ev){
        ev.preventDefault();
        const center = active.getBoundingClientRect();
        const cx = center.left + center.width/2, cy = center.top + center.height/2;
        function mm(e){
          const ang = Math.atan2(e.clientY-cy, e.clientX-cx) * 180/Math.PI + 90;
          active.dataset.r = ang.toFixed(1);
          applyTRS();
          positionHandles();
        }
        function up(){ window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', up); mgr.updateLastTransform(leaderId); }
        window.addEventListener('mousemove', mm); window.addEventListener('mouseup', up);
      }

      function applyTRS(){
        const s=parseFloat(active.dataset.s)||1;
        const r=parseFloat(active.dataset.r)||0;
        active.style.transform=`translate(-50%,-50%) scale(${s}) rotate(${r}deg)`;
      }

      bar.addEventListener('click', (e)=>{
        const act = e.target.getAttribute('data-act');
        if(!act) return;
        if(act==='align'){ enableAlign(); }
        
        if(act==='snap-center'){ if(select()){ active.dataset.x=0.5; active.dataset.y=0.5; active.style.left='50%'; active.style.top='50%'; applyTRS(); positionHandles(); mgr.updateLastTransform(leaderId);} }
        if(act==='left'){ if(select()){ active.dataset.x=0.0; active.style.left='0%'; mgr.updateLastTransform(leaderId); positionHandles(); } }
        if(act==='right'){ if(select()){ active.dataset.x=1.0; active.style.left='100%'; mgr.updateLastTransform(leaderId); positionHandles(); } }
        if(act==='top'){ if(select()){ active.dataset.y=0.0; active.style.top='0%'; mgr.updateLastTransform(leaderId); positionHandles(); } }
        if(act==='bottom'){ if(select()){ active.dataset.y=1.0; active.style.top='100%'; mgr.updateLastTransform(leaderId); positionHandles(); } }
        if(act==='flip'){ if(select()){ const cur=active.style.transform.includes('scaleX(-1)'); active.style.transform = active.style.transform.replace(/scaleX\((?:-?1)\)/,'') + ` scaleX(${cur?1:-1})`; mgr.updateLastTransform(leaderId); } }
        if(act==='front'){ if(select()){ active.parentElement.appendChild(active); positionHandles(); mgr.updateLastTransform(leaderId);} }
        if(act==='back'){ if(select()){ active.parentElement.insertBefore(active, active.parentElement.firstChild); positionHandles(); mgr.updateLastTransform(leaderId);} }
        if(act==='dup'){ if(select()){ const clone=active.cloneNode(true); clone.style.pointerEvents='auto'; wrap.querySelector('.sb-acc-layer').appendChild(clone); select(clone); mgr.add(leaderId, {url: clone.src, x: parseFloat(clone.dataset.x)||0.5, y: parseFloat(clone.dataset.y)||0.5, s: parseFloat(clone.dataset.s)||1, r: parseFloat(clone.dataset.r)||0}); } }
        if(act==='grid'){ grid.classList.toggle('show'); }
if(act==='save'){ mgr.updateLastTransform(leaderId); alert('Saved accessory transform.'); }
        if(act==='clear'){ disableAlign(); mgr.clear(leaderId); }
        if(act==='exit'){ disableAlign(); bar.remove(); hint.remove(); }
      });
    }

    // Patch Character page after your app renders it
    function leaderId(){
      const sel=document.querySelector('#leader');
      return sel?.value || 'bambi';
    }
    async function patchCharacter(){
      const portrait=document.querySelector('#heroBase, #charPortrait, .portrait-wrap img, .char-portrait img'); if(!portrait) return;
      const wrap=portrait.closest('.portrait-wrap, .char-portrait')||portrait.parentElement;
      wrap.style.position = wrap.style.position || 'relative';
      // ensure layer anchored to the IMG box, not the whole wrap
      let layer=wrap.querySelector('.sb-acc-layer');
      if(!layer){ layer=document.createElement('div'); layer.className='sb-acc-layer'; wrap.appendChild(layer) }
      function sizeLayer(){ const r=portrait.getBoundingClientRect(); const w=wrap.getBoundingClientRect(); layer.style.position='absolute'; layer.style.left=(r.left-w.left)+'px'; layer.style.top=(r.top-w.top)+'px'; layer.style.width=r.width+'px'; layer.style.height=r.height+'px'; layer.style.zIndex=1; }
      sizeLayer(); new ResizeObserver(()=>sizeLayer()).observe(wrap);

      const mgr=new OverlayMgr(layer);
      await mgr.load(leaderId());

      // wire buttons if present
      const addBtn=document.querySelector('#addAcc');
      const fileIn=document.querySelector('#accFile');
      const clrBtn=document.querySelector('#clearAcc');
      if(addBtn && fileIn && !addBtn._wired){
        addBtn._wired=true;
        addBtn.addEventListener('click', async ()=>{
          const f=fileIn.files && fileIn.files[0]; if(!f){ alert('Choose an image first'); return; }
          try{
            const id=await idbPut(f); const url=await idbGetURL(id);
            if(!url){ alert('Accessory load failed'); return; }
            await mgr.add(leaderId(), { id, url, x:0.5, y:0.5, s:1, r:0 });
            injectAlignUI(wrap, mgr, leaderId());
            alert('Accessory added. Use the Align toolbar (top-left of portrait).');
          }catch(err){ console.error(err); alert('Accessory add failed: '+err); }
        });
      }
      if(clrBtn && !clrBtn._wired){
        clrBtn._wired=true;
        clrBtn.addEventListener('click', async ()=>{ await mgr.clear(leaderId()); alert('Cleared overlays.'); });
      }

      // if thereâ€™s already an overlay, show the toolbar
      if (layer.querySelector('.sb-acc-ov')) injectAlignUI(wrap, mgr, leaderId());
    }

    function onRoute(){ setTimeout(patchCharacter, 60) }
    window.addEventListener('hashchange', onRoute);
    document.addEventListener('DOMContentLoaded', onRoute);
    setTimeout(onRoute, 200);
  })();
</script>


</body>
</html>
